{
    "collab_server" : "",
    "contents" : "################################################################################\n# SemiExh impelement a feature selection method called semi-exhaustive #########\n################################################################################\n\n#remove duplicated feature sets.\nRmDupVal <- function(features){\n    features <- t(apply(features, 1, sort))\n    features <- subset(features, duplicated(features) == F)\n    return(features)\n}\n\nLRWithFixedVal <- function(para){\n    x <- para$x\n    y <- para$y\n    n.comb <- para$n.comb\n    error.threshhold <- para$error.threshhold\n    fold <- para$fold\n    device.id <- para$device.id\n    fixed.features <- para$fixed.features\n    \n    result <- .Call(\"LRCUDAWithFixedVal\", t(x), y, as.integer(n.comb), as.integer(error.threshhold), as.integer(fold), as.integer(device.id), t(fixed.features), nrow(fixed.features), ncol(fixed.features))\n\n    #######################################################\n    #output format should be consistent\n    ######################################################\n    result <- t(matrix(result, nrow = n.comb + ncol(fixed.features)+1 ))\n    result <- as.data.frame(result)\n    features.name <- paste0(\"feature\", 1:(ncol(result)-1))\n    names(result) <- c(features.name, \"error\")\n    return(result)\n\n}\n\nLRWithFixedValMG <- function(x, y, n.comb = 1, error.threshhold = 0 , fold = 10, device.id = 0, cl = NULL, fixed.features){\n    if(!is.matrix(x)){\n        stop(\"x should be matrix type !\")\n    }\n  \n    if(nrow(x) != length(y)){\n        stop(\"x'rows is different from y'length !\")\n    }\n    x <- cbind(rep(1, nrow(x)), x)\n    if(is.null(cl)){\n        cl <- makeCluster(length(device.id), type = \"SOCK\")\n    }else{\n        if(length(cl) != length(device.id)){\n            stop(\"device count should be equal to cluster size! Please check you configures.\")\n        }\n    }\n    task.num <- nrow(fixed.features)\n    print(paste(\"task.num\", task.num))\n    ####################################################### \n    #when task.num is less than device.num\n    #######################################################\n    if (task.num < length(device.id)){\n        device.id <- device.id[1:task.num]\n        cl <- cl[1:task.num]\n    }\n    device.num <- length(device.id)\n\n    clusterEvalQ(cl,library(LRCUDA))\n    para <- vector(\"list\", device.num)\n    task.piece <- floor(task.num / device.num)\n   \n    for(i in 1:device.num){\n        if(i != device.num){\n            para[[i]] <- list(x = x, y = y, n.comb = n.comb, error.threshhold = error.threshhold, fold = fold, device.id = device.id[i], fixed.features = as.matrix(fixed.features[((i-1)*task.piece + 1):(i*task.piece),]))\n            #print(n.comb)\n            #print(error.threshhold)\n            #print(fold)\n            #print(device.id[i])\n            #print(nrow(fixed.features[((i-1)*task.piece + 1):(i*task.piece),]))\n            #print(ncol(fixed.features[((i-1)*task.piece + 1):(i*task.piece),]))\n        }else{\n            para[[i]] <- list(x = x, y = y, n.comb = n.comb, error.threshhold = error.threshhold, fold = fold, device.id = device.id[i], fixed.features = as.matrix(fixed.features[((i-1)*task.piece + 1):(nrow(fixed.features)),]))\n            #print(n.comb)\n            #print(error.threshhold)\n            #print(fold)\n            #print(device.id[i])\n            #print(nrow(fixed.features[((i-1)*task.piece + 1):(nrow(fixed.features)),]))\n            #print(ncol(fixed.features[((i-1)*task.piece + 1):(nrow(fixed.features)),]))\n        }\n        \n    }\n    \n    result <- clusterApply(cl, para, LRWithFixedVal)\n    result <- do.call(\"rbind\", result)\n    return(result)\n}\n\n\n\nSemiExh <- function(x, y, error.threshhold = 0, fold = 10, device.id = 0, cl = NULL){\n\n    ############################################################################\n    #one feature: error.threshhold is set to half of training set num.\n    ############################################################################\n\n    result.l <- list()\n   # rand.index <- sample(1:length(y), length(y))\n    result.one <- LRCUDA(x = x, y = y, n.comb = 1, error.threshhold = length(y) / 2, fold = fold, device.id = device.id, cl = cl)\n    if(nrow(result.one) == 0){\n         print(\"use one feature can't statisfy the error threshhold\")\n         return(result.l)\n    }\n    result.l[[1]] <- result.one\n    error.min.one <- min(result.one$error)\n    print(paste(\"error.min.one\", error.min.one))\n    if(error.min.one <= error.threshhold){\n        return(result.l)\n    }else{\n        #save(result.one, file = \"result.one.feature.RData\")\n    }\n    \n    ############################################################################\n    #two features: error.threshhold is set to error.min.one\n    ############################################################################\n \n    fixed.features <- result.one[,1]\n    #rand.index <- sample(1:length(y), length(y))    \n    result.two <- LRWithFixedValMG(x, y, n.comb = 1, error.threshhold = error.min.one, fold = fold, device.id = device.id , cl = cl, fixed.features = as.matrix(fixed.features))\n    \n    if(nrow(result.two) == 0){\n        print(\"use two features can't satisfy the error theshhold\")\n        return(result.l)\n    }\n    result.l[[2]] <- result.two    \n    error.min.two <- min(result.two$error)\n    if(error.min.two <= error.threshhold){\n        return(result.l)\n    }\n    #save(result.two, file = \"result.two.features.RData\")\n    print(paste(\"error.min.two\", error.min.two))\n   \n    ############################################################################\n    #three or more features, max number of features in model is 9.\n    ############################################################################\n\n    fixed.features <- RmDupVal(result.two[,1:2])\n    error.para <- error.min.two\n    for(i in 3:9){\n        print(paste(\"i = \", i))\n        print(paste(\"fixed features num\", nrow(fixed.features)))\n        #rand.index <- sample(1:length(y), length(y))\n        result <- LRWithFixedValMG(x, y, n.comb = 1, error.threshhold = error.para, fold = fold, device.id = device.id ,cl = cl, fixed.features = as.matrix(fixed.features))\n        \n        if(nrow(result) == 0){\n            print(paste(\"use\", i+1 ,  \"feature can't statisfy the error threshhold\"))\n            return(result.l)\n        }\n        result.l[[i]] <- result\n        error.min <- min(result$error)\n        if(error.min <= error.threshhold){\n            return(result.l)\n        }\n        else{\n            #save(result, file = paste0(\"features\", i, \".RData\"))\n        }\n        fixed.features <- RmDupVal(result[,1:i])\n        error.para <- error.min\n        \n    }\n    return(result.l) \n}\n\nLRWithFixedValMG()\n",
    "created" : 1504841714472.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1091483193",
    "id" : "C9F142D9",
    "lastKnownWriteTime" : 1504838060,
    "last_content_update" : 1504838060,
    "path" : "~/Documents/LRCUDA/R/SemiExh.R",
    "project_path" : "R/SemiExh.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}